<h1>Linux Hax</h1>
<p>This started out as a general unix shell primer/reference page for noobs, inspired by a lot of emails written to help colleagues that were getting used to unix based operating systems. I tried to focus on features and cultural norms that are so fundamental to experienced users that they often dont mention them. I have seen this manifest in stark realities such as people that are unaware of tab-to-complete after an embarrassingly long period of daily linux use. It has widened in scope a little to include brief tutorial on important basic userland tools, and reference notes for myself and other advanced users on things that see helpful but infrequent use.</p>
<h1>Convention</h1>
<p>This is notation and syntactic commonalities reflected in this document and others like it, not strict syntax but some generally unspoken entrenched cultural features that might confuse unix noobs when they take a look at a man page or a document like this.</p>
<ul>
<li><code>[expression]</code> - same as <code>&lt;expression&gt;</code> described above, this is more common in man pages
<ul>
<li><code>[expression]...</code> - entire <code>[expression]</code> is repeatable. Many commands can take an unbounded list of args, ex: <code>ls [file]...</code>  refers to the fact that <code>ls file1 file2 file3 ...</code> is valid syntax</li>
</ul>
</li>
<li><code>&lt;x&gt;</code> - a common notation for unspecified commands/parameters in unix man pages and such is surrounding a name or description of a quantity or string with the <code>&lt;</code> and <code>&gt;</code>.  es: <code>ls &lt;folder&gt;</code></li>
<li><code>[ctrl]-x</code> - hold control and x both for a moment, <code>x-y z</code> hold x and y for a moment, release both, hit z</li>
<li><code>[BUTTON]</code>  - hit a button labeled BUTTON on your keyboard</li>
<li><code>&lt;cmd&gt; --arg-name -a &lt;VAL1&gt; --arg2 &lt;VAL2&gt;</code> - it is very common for single character args to use a single <code>-</code> and multi-char to use two like <code>--arg</code>, and use another <code>-</code> to separate words. This is also cultural convention, command line args can be anything and are tokenized on whitespace. flag options like <code>-a -b</code> are generally commutative(order doesnt matter) and can be grouped. so <code>-ab</code> and <code>-ba</code> and <code>-b -a</code> would all be the same to the former. argument values (denoted <code>&lt;VAL`&gt;</code> and <code>&lt;VAL2&gt;</code> above, are not commutative and sometimes option flags are grouped with argument values so they are only commutative within that block rather than on the whole line.</li>
<li><code>&lt;cmd&gt; --help</code> - common, quite standard, basically all modern command line utils have this arg to give you a refresh on the syntax, args available. This is however, a feature of the package itself and only ubiquitous due to cultural convention and voluntary adherence thereof. often <code>-h</code> is equivalent</li>
<li><code>RTFM</code> - means read the fucking manual IE check <code>man</code>, common use context is in a response to someone who wants to be spoon fed like a baby and cant read his own error messages... (you know who you are)</li>
<li><strong>middle button copypaste</strong> - unix machines use 3 button mice and the middle button takes whatever text you have highlighted and pastes it to your text cursor/carat location. It does not use your regular copy paste buffer that modern interfaces use for <code>ctrl-c</code> and mouse-right-click-menu copypaste. This is pre-GUI feature and works in terminals. Modern mice have a scroll wheel which made the 3 buttons ubiquitous, but before that, it would be emulated by simultaneous actuation of both buttons in the case of a two button mouse. Some editors paste the text out to the location of the mouse pointer rather than the carat.</li>
</ul>
<h1>Basic general unix shell commands</h1>
<ul>
<li>
<p><code>ls</code> - list files</p>
<ul>
<li><code>ls -al</code> - list all files with extra information</li>
</ul>
</li>
<li>
<p><code>mv</code> - move file/folder</p>
</li>
<li>
<p><code>cp</code> - copy file/folder</p>
<ul>
<li><code>cp -r</code> - copy folder recursively</li>
</ul>
</li>
<li>
<p><code>pwd</code> - gives u the current directory, like which, full path</p>
</li>
<li>
<p><code>rm</code> - delete file</p>
<ul>
<li><code>rm -rf</code> - remove folder recursively and force, IE, ignore all warnings. yes it will delete the whole drive if run as sudo on /</li>
</ul>
</li>
<li>
<p><code>mkdir</code> - makes an empty directory</p>
</li>
<li>
<p><code>touch</code> - makes an empty file</p>
</li>
<li>
<p><code>rmdir</code> - remove empty directory only(safety feature)</p>
</li>
<li>
<p><code>less</code> - read a file that is longer than the screen. scroll by hitting enter, space, arrows, pgdown, search with <code>/</code> use q to quit</p>
</li>
<li>
<p><code>su</code> - setuser/superuser its supposed to stand for, su bob will make your user bob, you need his password. su makes u root(if you have a root password</p>
</li>
<li>
<p><code>sudo</code> - run a command as root, became the normal way to do things in administration after a while. before it was just get a root shell with su. it will ask for a password and if you are an admin user yours will work. you have to be in the group sudoers.</p>
</li>
<li>
<p><code>more</code> - basically the same as less but slightly different in an unmemorable and barely perceivable way</p>
</li>
<li>
<p><code>top</code> - like task manager, list everything. full featured interface, can kill things, sort everything, etc <code>htop</code> is very similar with a more attractive ncurses interface</p>
</li>
<li>
<p><code>rsync</code> - sync directories locally or over ssh or other transport</p>
<ul>
<li><code>rsync -av --progress &lt;folder1&gt; &lt;folder2&gt;</code> - copy large folder with progress bar, preserve permissions</li>
<li><code>rsync -avP --append-verify -rsh=ssh user@host:/path/ user@host2:/path/backup</code> - copy, omittings files with matching size that already exist in host2 at said path,</li>
<li>use <code>-c</code> to use a checksum instead of just file size compare. omit ssh args to use locally</li>
</ul>
</li>
<li>
<p><code>ps</code> - list processes defaults to ones in your shell</p>
<ul>
<li><code>ps aux</code>- lists processes from all users with more information</li>
</ul>
</li>
<li>
<p><code>grep</code> - search files for string or regular expression, print whole line</p>
<ul>
<li><code>grep -v</code> - exclude files</li>
<li><code>grep -A n -B m</code> - print lines n after matching line and m before matching line</li>
</ul>
</li>
<li>
<p><code>kill</code> - end process with signal 15, smooth exit</p>
<ul>
<li><code>kill -s 9</code> - end it right now, no shutdown sequence</li>
</ul>
</li>
<li>
<p><code>cat</code> - spit entire file to stout</p>
</li>
<li>
<p><code>curl</code> - send http request and spit output to stdout</p>
</li>
<li>
<p><code>nc</code> - netcat, same as cat but uses raw tcp socket. can work on udp too</p>
<ul>
<li><code>nc -l &lt;n&gt;</code> - listen on on tcp port <n> , write received data to stdout, add <code>-u</code> for udp</li>
</ul>
</li>
<li>
<p><code>sed</code> - more advanced regular expression oriented grep with in-place editing focus</p>
</li>
<li>
<p><code>awk</code> - similar to sed, complex grep type thing regexps in-place editing etc</p>
</li>
<li>
<p><code>perl</code> - a whole language like python, partially specialized for the tasks sed and awk do, can write one liners in shell. regexps</p>
</li>
<li>
<p><code>chmod</code> - modify permissions, uses a number code of 3 digits or letter</p>
<ul>
<li><code>cmod +x file</code> - set file to be executable</li>
<li><code>chmod 777</code> - let all users read write and execute. don't do it</li>
<li><code>chmod 666</code> - all users read and write,</li>
<li><code>chmod 600</code> - your user can read and write</li>
<li><code>chmod 770</code> - owner user and owner group can read write and execute</li>
</ul>
</li>
<li>
<p><code>man</code> - manual page, <code>man &lt;command&gt;</code> shows the man page, short for manual. This is the manual they speak of when they tell you to RTFM. There are entries for config files, too, to reference their syntex. <code>man resolv.conf</code> there are entries for pam plugins and such <code>man pam_u2f</code>. For some utilitiesl ike git, there are entries for subcommands <code>man git-pull</code> for a manual on all the args, syntax, behavior of <code>git pull</code></p>
</li>
<li>
<p><code>screen</code> - make a new screen/tty, allowing you to have multiple terminals running independently. <code>ctrl-a (release) d</code> detaches/exits from it, <code>ctl-a c</code> closes. this is one way you run things in the background and let them run after logout. <code>screen -r</code> resumes screen you deteched from, if multiple, it lists them. <code>screen -r 45</code> will resume the screen with id starting with 45 and list if there are multiple.</p>
</li>
<li>
<p><code>tmux</code> - terminal multiplexer, lets you squeeze multiple terminals into one screen. like a super old school window manager</p>
</li>
<li>
<p><code>nohup</code> - precedes command and prevents hangup signals from hitting it so it will run until killed or closed from internal logic. alternative to screen for background process tat will persist on logout</p>
</li>
<li>
<p><code>md5sum</code> - jsut called md5 on mac/bsd just does an md5 checksum hash of a file. for comparison of files of any size</p>
</li>
<li>
<p><code>sha256sum</code> - same as above woth sha256 algorithm. also exists others.</p>
</li>
<li>
<p><code>who</code> - lists out the current logins/screens. shows u who is logged in(which users and where)</p>
</li>
<li>
<p><code>whoami</code> - tells u which user u are. used to check if you've successfully hacked things and became root. or in innocent shell scripts</p>
</li>
<li>
<p><code>lsof</code> - spit out data about various things going on with processes and devices and filesystem. example lsof -i:8000 gives u info about proc using port 8000</p>
</li>
<li>
<p><code>lsusb</code> - list the usb devs. good to check if it can see a device</p>
</li>
<li>
<p><code>lspci</code> - same but for pci devices</p>
</li>
<li>
<p><code>sort</code> - sorts text file line by line</p>
</li>
<li>
<p><code>find</code> - for searching the file system. most stupid way can be done like <code>find .|grep filenameiwant</code>. recursive list of full dir tree is the default behavior</p>
</li>
<li>
<p><code>uniq</code> - deletes duplicate lines that appear next to eachother in text.</p>
</li>
<li>
<p><code>echo</code> - prints whatever is in its args to stdout</p>
</li>
<li>
<p><code>which</code> - gives total path to an executable in the shell path</p>
</li>
<li>
<p><code>strings</code> - spits strings out from binary file</p>
</li>
<li>
<p><code>hexdump</code> - spits out hex of a file</p>
</li>
<li>
<p><code>diff</code> - gives u the difference of 2(text) files line by line. yes this is where the term diff comes from in git repos etc</p>
</li>
<li>
<p><code>tar</code> - deals with tar archives. to untar a tar.gz tar xvzf file.tar.gz, for tar.bz2, tar xvjf</p>
</li>
<li>
<p><code>gzip</code> - compression. works on one file, takes input from file or stdout(!) good on text, fast</p>
</li>
<li>
<p><code>bzip2</code> - slower more intense compression</p>
</li>
<li>
<p><code>gunzip</code> - un-gzipps file</p>
</li>
<li>
<p><code>bunzip2</code> - unbz2 a file</p>
</li>
<li>
<p><code>zcat</code> - gunzip and contents to stdout</p>
</li>
<li>
<p><code>zgrep</code> - greps compressed data, IE same as <code>zcat &lt;file&gt;|grep &lt;word&gt;</code></p>
</li>
<li>
<p><code>bzgrep</code> - grep a bzfile, handy, exists also bzless bzcat bzexe... same as with above</p>
</li>
<li>
<p><code>lsblk</code> - list block devices. handy to se drives that are not mounted</p>
</li>
<li>
<p><code>df -h</code> - lists mounted drives with size ad free space in human readable format</p>
</li>
<li>
<p><code>du -h</code> - check file size. it is recursive by default so it is good to set the max view depth with -d 0. <code>du -h -d 0</code> file</p>
</li>
<li>
<p><code>lsmod</code> - list kernel modules(generally are drivers), whcih are code that can be hotplugged into the kernel. this is used when trubleshooting hardware and driver issues</p>
</li>
<li>
<p><code>modprobe</code> - load up a module, they ahve a path thing built in so you can tab tab to see whats available</p>
</li>
<li>
<p><code>time</code> - TIMES A COMMAND in human readable down to ms</p>
</li>
<li>
<p><code>date</code> - the timestamp in a human readable format, can spit out other formats check man page</p>
</li>
<li>
<p><code>ln</code> - typically invoked as <code>ln -s &lt;target&gt; &lt;link_name&gt;</code>, which creates a symbolic link</p>
</li>
<li>
<p><code>fsck</code> - checks hard drives</p>
</li>
<li>
<p><code>fdisk</code> - partition hard drves</p>
</li>
<li>
<p><code>parted</code> - more up to date and full featured alternative to the archaic fdisk, graphical interface is <code>gparted</code></p>
</li>
<li>
<p><code>testdisk</code> - advanced hard drive configuration, partitioning, analysis, forensic and data recovery tool. allows you to change things like logical sector size while fdisk and parted seem impotent to this effect</p>
</li>
<li>
<p><code>mkfs</code> - makes the default fs, ext4 or whatever your system thinks is the default, for other fs do <code>mkfs.&lt;x&gt;</code> or <code>mkfs -t &lt;x&gt;</code> , examples for <code>&lt;x&gt;</code> are <code>vfat, ext2, ext3, ext4, exfat, xfs</code></p>
</li>
<li>
<p><code>yes</code> - endless loop of 'y'... for dealign with annoying menus with the y/n? prompts using pipe</p>
</li>
<li>
<p><code>wipefs</code> - removed disk label</p>
</li>
<li>
<p><code>shred</code> - destroy files by writing random data to the location they were stored on disk(doesnt work on some filesystems) or write random data to a whole disk</p>
</li>
<li>
<p><code>cron</code> - service for running periodic tasks.</p>
</li>
<li>
<p><code>ranger</code> - file explorer command line tool. vim bindings, written in python. navigate filesystem in ncurses text interface</p>
</li>
<li>
<p><code>lfm</code> - shitty version of ranger seems really old</p>
</li>
<li>
<p><code>lf</code> - newer unfinished version of ranger lighter and focused on the use of external tools to open things, not in repos https://github.com/gokcehan/lf</p>
</li>
<li>
<p><code>head</code>- get top 10 lines of the file, use -n to specify numlines</p>
</li>
<li>
<p><code>tail</code>- some as above, last 10 lines as default</p>
</li>
<li>
<p><code>cut</code>- more general than the 2 above, check the manpage, cuts on chars, bytes, lines, delimiter separated fields....</p>
</li>
<li>
<p><code>fold</code>- chop up input from stdin and wrap it with newlines to enforce a certain width on text.</p>
</li>
<li>
<p><code>last</code> - show log of your users logins</p>
</li>
<li>
<p><code>lslogins</code> - list login statistics for all accounts</p>
</li>
<li>
<p><code>bc</code> - basic calculator, supports arbitrary precision</p>
<ul>
<li><code>echo 1 + 1 | bc</code></li>
</ul>
</li>
<li>
<p><code>tee &lt;file&gt;</code> - output stdin to stdout and to file.</p>
</li>
</ul>
<h1>editors:</h1>
<ul>
<li><code>vi</code> - the old version of vim. it sucks. if u have a new install and type vi this is what is usually there. it makes people hate vim. dont use it. install vim and it will clobber the path to this</li>
<li><code>vim</code> - the new version of vi, if installed will alias as vi overriding above command, for serious people only. perfect for people that hate their mouse. extensible to the point of absurdity. it is a modal editor, meaning it has modes of interaction with the file. hit escape to dissasociate from a mode, hit a letter to change to that mode. in this case the letter <code>i</code> is insert (normal edit mode), <code>v</code> is visual(select and delete copy and stuff large blocks to text). in the default mode and in visual <code>d</code> is delete, hit it twice to delete a line. visual mode <code>d</code> deletes selection. <code>u</code> is undo. the  <code>:</code> char (yes use shift) lets u type in commands for user defined things and interactions with filesystem. <code>:w</code> is write. <code>:wq</code> is write and quit. <code>:q</code> is quit. <code>q!</code> is quit RTFN with no confirmation. <code>:r &lt;file&gt;</code> is read(a file and output it at current cursor position). <code>:read !&lt;commands&gt;</code> does the same for a shell command <code>! &lt;cmd&gt;</code> opens the shell and hides the editor, returning when you exit</li>
<li><code>elvis</code> - this is another editor, a better version of vi, lighter than vim(if i remember correctly)</li>
<li><code>nvim</code> - neovim, a new and cooler vim that people who think theyre cool use. also has qt graphical neovim-qt, apparently feature-rich with a more informed design architecture and cleaner codebase as it was written more recently</li>
<li><code>pico</code> - simple old editor not sure its ever used anymore.</li>
<li><code>nano</code> - a fork/copy/something of pico, newer, good for noobs, often used and well respected. commands are on the screen when using it and ctrl-X based.</li>
<li><code>emacs</code> - a complex and extensible editor, bulky for a command line utility. generally serious editor nerds that use stuff in this section use either emacs or vim, and have strong convictions about it.</li>
<li><code>ed</code> - the simplest editor from extremely long time ago, only used in extreme emergencies. the kind of editor a eunich would use.</li>
<li><code>gedit</code> - simple grpahical editor, good, basically notepad with syntax highlighting.</li>
</ul>
<h1>system things(debian based mint/ubuntu):</h1>
<ul>
<li><code>sudo</code> - run following command as root (admin)</li>
<li><code>su</code> - set user, defaults to root. can specify shell with -s</li>
<li><code>service</code> - control a service's ephemeral state and status check. service <name of it> &lt;start, stop, restart, reload&gt;   ex: sudo service postgresql restart</li>
<li><code>systemctl</code> - controls systemd services state and settings. This includes everything that you can control with the above command, plus user services, startup behavior of system and user services. <code>systemctl &lt;start, stop, enable, disable , mask, unmask&gt; &lt;Service-name&gt;</code> covers most of the stuff you use</li>
<li><code>hostname</code> - prints hostname, if given arg it will set the hostname to the arg. if u do this, should also manually change /etc/hostname and make sure /etc/hosts refects that change if necessary</li>
<li><code>adduser</code> -<code>adduser &lt;newusername&gt;</code> makes a new user. many options. none are really required, even a password. interactive walk through</li>
<li><code>useradd</code> - more l33t version of <code>adduser</code>. more useful noninteractively and non-user-friendly</li>
<li><code>usermod</code> - mod shell and stuff of a givemn user usermod -aG common for adding group</li>
<li><code>passwd</code> - password change, <code>passwd &lt;user&gt;</code> does it for user when u are admin</li>
<li><code>dd</code> - writes raw data. dd if=indevice of=outdevice bs=1M. if is a filesyste object to be read, of is the filesystem object to be written and bs is the block size which can be written human readable like 1M 2M 4M and in bytes like 1024(the old way). you use this when wipeing disks with random data. you use it when 'burning' a flash drive with a disk image like dd if=linux.iso of=/dev/sdc bs=4M. If you mess up with this as root you can easily overwrite your hard drive. do not do it to mounted filesystem</li>
<li><code>chsh</code>- change the shell for a user</li>
<li><code>chgroup</code>- change group of file... group ownership</li>
<li><code>chmod</code>- change permissions of file chmod 777 file makes everyone read write ex it, chmod 666 is read write for all.... chmod 600 is another common one ls -al will show the perms</li>
<li><code>mount</code> - attaches a block device to a folder, allowing you to browse the filesystem</li>
<li><code>umount</code>- unmounts somethign takes mountpoint or /dev /device as target</li>
<li><code>dmesg</code>- prints messages generated at boot</li>
<li><code>env</code>- show ur environment vars, set them then run command(too)</li>
<li><code>uptime</code>- time up</li>
<li><code>wipefs</code>- removed disk label</li>
<li><code>cryptsetup</code> - setup luks volumes</li>
<li><code>cron</code>- service for running periodic tasks.</li>
</ul>
<h1>shells:</h1>
<ul>
<li><code>bash</code> - common, youre prob on it. "bourne again shell" whatever that means</li>
<li><code>csh</code> - different, advanced too - C shell</li>
<li><code>tcsh</code> - mac uses it? freebsd? its good too</li>
<li><code>zsh</code> - another shell that some nerds are all about, like the previous 2</li>
<li><code>sh</code> - the most simple bare bones one used when there is nothing else in some broke-ass embedded system or something, no tab to complete, no features, you run it because its always there on every system, common hack entrypoint to spawn a shell in a priv upgrade or somesort of remote code exe sploit</li>
</ul>
<h1>env vars:</h1>
<p>The shell has a namespace of variables called environment variables. many settings for the shell and for other programs you run are set by these variables. These settings tend to be preferences and other things that tend to be seldom changed by the same user in the same machine. Or for situations where the command line syntax used at call cant be changed for one reason or another.</p>
<p>type <code>env</code> to see them all. <code>echo $VAR</code> to see VAR. <code>export VAR=sgfsgs</code> to set VAR to sgfsgs for your session. setting <code>VAR=5 someprogram</code>, will modify VAR in the context of that single line running someprogram.</p>
<p>shell vars in general have a <code>$</code> infront of them when you access them, but not when you set them.</p>
<ul>
<li><code>$PATH</code> - path to binaries, default is /bin /usr/bin /usr/local/bin  etc</li>
<li><code>$DISPLAY</code> - x11/xorg display, typically :0. machines can have multiple displays, like all unix things, its multiuser</li>
<li><code>$PYTHONPATH</code> - where python looks for modules</li>
<li><code>$USER, $HOME</code>, - username and home directory path</li>
<li><code>$PWD</code> - absolute path to current working directory</li>
<li><code>$EDITOR</code> - default editor, adults set to <code>vim</code> kids set to <code>nano</code> . read by system utils like apt and other things that launch an editor from time to time</li>
<li><code>$_</code> - last arg from previous shell command run</li>
<li><code>$?</code> - exit value/signal from prev command (0 if success which you manually throw in scripts with <code>exit 0</code></li>
<li><code>$([expression])</code> - treats output of [expression] as if it were a variable(rather than literal)</li>
<li><code>$(!!)</code> - previous command's output(command is re-run)</li>
<li><code>alias</code> - it is a command that tells the shell to make a macro for other commands, generally default bashrc will have some use of it and generally anything you want to do like this is done better with a function def</li>
<li><code>env</code> shows your env</li>
<li><code>export</code> - declare env var for remainder of session until u close this shell</li>
<li><code>jobs</code> - lists the jobs in shell(if you have paused with ctrl-z) with jobid</li>
<li><code>bg &lt;jobid&gt;</code> and <code>fg &lt;jobid&gt;</code> - background a paused job or foreground a paused job respectively.</li>
</ul>
<h1>strange obscure barely useful:</h1>
<ul>
<li><code>motd</code> - message of the day, displayed on login, not all systems have this command, its old school, but having an MOTD is not a dead art.</li>
<li><code>links</code> - text only browser</li>
<li><code>lynx</code> - older more useless text only browser</li>
<li><code>irssi</code> - irc client ncurses flavor. leet af only good program in this section</li>
<li><code>rexima</code> - command line sound volume control mixer thingy</li>
<li><code>beep</code> - makes a console beep</li>
</ul>
<h1>graphical, featureful</h1>
<ul>
<li><code>xterm</code> - old school bare bones terminal emulator for x11</li>
<li>xorg/x11 - always started by scripts, but it is the name of the service that runs the GUI in linux generally. x1 was the old name xorg is the new one. there are forks...</li>
<li><code>xv</code> - old and simple image viewer. seems to be somehow replaced by <code>xviewer</code> and some systems may have it as <code>xview</code></li>
<li><code>mplayer</code> - old simple and great media player. no GUI, just do mplayer file.mp4 or whatnot</li>
<li><code>mpv</code> - like mplayer but better, has no interface other than key bindings and cmdline</li>
<li><code>gimp</code> - powerful image editing, old schoool MIT project, shit interface, opens any format basically</li>
<li><code>ibus</code> - this is a package for controlling advanced input methods that are a lot more than a change of layout; like Chinese, Korean,</li>
<li><code>display</code> -  another nice CLI for imgmagick. functionally same/similar to xviewer only it will take input from STDIN which is great.</li>
<li><code>librewolf</code> - probably best browser at time of writing this, firefox with telemetry removed and other security enhancements</li>
<li><code>zathura</code> - -good pdf viewer, cool kids use it these days, suckless minimalist</li>
<li><code>xpra</code> - like screen but for graphical apps. useful for video editing on a server with a big GPU remotely. normal x forwarding over ssh just forwards the X11 instructions and renders on the client, but this can render on the server and compress it, send it to you as a video stream.</li>
</ul>
<h1>crypto</h1>
<ul>
<li><code>gnupg</code> - <code>gpg</code> a gnu implementation of pgp aka 'pretty good privacy' the first common userland well adopted implementation of modern cryptographic protection, mainly for emails and the like. has rsa and the like, MAC methods and all that.  as per gnu naming conventions, its name is a goofy acronym based pun of sorts.</li>
<li><code>cryptsetup</code> - setup luks volumes. rtfm on it</li>
<li><code>openssl</code> - CLI for openssl library functionality, very handy for some specialty tasks, generating keys and hashking things</li>
<li><code>pass</code> - password manager that uses gnupg. integrates with git, can be used to run google auth type 2fa, responds to tab to complete well. extensible with plugins. basic commands are <code>pass insert</code>, <code>pass show &lt;name&gt;</code>, <code>pass edit &lt;name&gt;</code>. initialize with <code>pass init</code> after making a keyriung with gnupg</li>
<li><code>openpgp-tool</code> - openpgp smartcard device control.</li>
<li><code>fido2-token</code> - manage, manipulate fido2 security keys</li>
</ul>
<h1>network &amp; hax</h1>
<ul>
<li><code>nmap</code> - port scanner highly advanced, many modes and options</li>
<li><code>masscan</code> - speed optimized port scanner for large volume scanning, target acquisition. usually preceeds  the use of nmap whcih yields more detailed information</li>
<li><code>nc</code> - previously merntioned, netcat, raw conns <code>nc &lt;host&gt; &lt;port&gt;</code> does tcp conn. <code>-u</code> arg does udp and <code>-l</code> is listen</li>
<li><code>ettercap</code> - manipulation of ARP, DNS, other protocols, generally for the purpose of man in the middle attack. it is bad to the bone, it is a cyberweapon</li>
<li><code>wireshark</code> - watch network packets go by. need to change group to work properly. can run as root and always works that way, but not recomended. used to be called ethereal - the new name sucks. still hate them for it. the new name reads like it should be the name of a chinese electrician tool or a korean children's cartoon</li>
<li><code>ngrep</code> - network grep, just reads packets going by your box and spits that out to stdout if it matches what ur looking for</li>
<li><code>tcpdump</code> - captures and dumps packets, dump files can be reloaded, minor dissection available with some calssification, can load the dumps up with anything</li>
<li><code>ifconfig</code> - old network interface config command line utility. windows ipconfig is the ripoff version with a weird name</li>
<li><code>ip</code> - the newer, 'better' network interface and routing table configuration tool</li>
<li><code>route</code> - orouting table edit and explore</li>
<li><code>httping</code> - sends a http packet to a server on default prot of 80, gives response time</li>
<li><code>ping</code> - normal old school icmp ping. not waht it used to be</li>
<li><code>telnet</code> - old school shell/terminal over the wire. completely unencrypted, not much more complex than netcat. helpful for testing connections, manual single prot probing like tenet <host> 80 to connect to port 80 on <host></li>
<li><code>nslookup</code> - look up an ip or hostname in DNS</li>
<li><code>john</code> - old school powerful password hash cracker. supports extensions and a lot of hash algorithms. parallelism exists too, not sure about GPU kernels. likely better things these days. called john the ripper(after the famous amteur serial hooker-vivisection enthusiast)</li>
<li><code>whois</code> - information on domain ownership, reverse look up of IP addresses. just an entry from a database about the owner and registrar stuff for IPs and domains.</li>
<li><code>traceroute</code> - old school packet routing trace, not sure if it really works the same anymore, but shows you the path packets take to a server. seems like maye routers out in the widl drop the packets it uses now often? not sure. dont use it much and its not what it used to be is the word</li>
<li><code>arping</code> - executes a ping-analogous function using the arp protocol. v nice.</li>
<li><code>tsocks</code> - wrap any protocol through socks generally config in etc</li>
<li><code>httping</code>- ping a http server. IE, give the response time to a http service</li>
<li><code>aircrack-ng</code> - a suite of utilities for security analysis of wifi networks</li>
<li><code>iwconfig</code>-ike ifconfig but with specific features for wifi adapters/driver interfaces. it is old school</li>
<li><code>iw</code> - same as above but not as old school</li>
<li><code>bluetoothctl</code>- shell style interface to bluetooth hardware. quite good</li>
<li><code>yersinia</code>- a powerful security analysis too that i am not too familiar with, but worth a mention. some kid in vegas looked at me like i was insane for not using it. appears very powerful.</li>
<li><code>netstat</code>- usually i invoke as netstat -n, lists the connections in and out of the machine. godo stuff is by the top so try netstat -n|head</li>
<li><code>fido2-token</code> - manipulate and probe fido2 auth tokens such as yubikey etc</li>
<li><code>opensc-tool</code> + <code>opensc-explorer</code> - cli util and interactive shell interface for smart card interactions a-la iso7816 and iso14443(contact chip and nfc interfaces respectively)</li>
<li><code>pcsc_scan</code> - report basic diagnostic info on connected smart cards</li>
</ul>
<h1>services</h1>
<p>these are the names used if you were to <code>service &lt;name&gt; &lt;start|stop|status&gt;</code> services are started stopped etc by scripts which are used by systemd and this command or in general your setup might use a different service manager, which will be similar. This is because some services need a sequence of commands and checks etc before starting or stopping safely.</p>
<ul>
<li><code>fail2ban</code> - great utility that watches update of logs from whatever you want and responds to predined events (you set up in /etc/fail2ban. modularized to actions filters and jails. where actions are responses, filters define events and jails define groups of events and how they trigger actions abd expire. all bans are cleared on restart by default.</li>
<li><code>nginx</code> - nice simple lightweight webserver, often used as a proxy to a web app run with python-flask or similar, to provide robust features that come with a real web server.</li>
<li><code>snort</code> - network util for traffic capture and parsing, logging. can be run in the background as a system service to construct intrusion detection functionality, or used like ngrep</li>
<li><code>psql</code> - best database</li>
</ul>
<h1>SSH STUFF</h1>
<ul>
<li>
<p><code>ssh &lt;user&gt;@&lt;remotehost&gt;</code> - secure shell, replaced telnet when people realised doing password based auth and all your work over cleartext in telnet was retarded and more dangerous than working in a liberian brothel</p>
</li>
<li>
<p><code>ssh-keygen</code> - generates keypairs for ssh auth</p>
<ul>
<li><code>ssh-keygen -lf .ssh/id_rsa -E sha256</code> - generate fingerprint of key</li>
<li><code>ssh-keygen -t ed25519-sk -O resident -O application=ssh:&lt;description&gt; -f ~/.ssh/id_ed_sk</code> - generate key on fido2 token as resident on key, type can alternatively be <code>ecdsa-sk</code>, omitting <code>-O resident</code> makes a key that requires the fido token but is not stored on it. not discoverable from the key. <code>-O verify-required</code> or <code>-O no-touch-required</code> control the physical prescene requirements(touching the key)</li>
<li><code>ssh-keygen -K</code> - importing resident keys to new machine from security token</li>
</ul>
</li>
<li>
<p><code>ssh-add -L</code> - print all your public keys in .ssh</p>
</li>
<li>
<p><code>scp localfile &lt;user&gt;@&lt;remotehost&gt;:/path/file</code> - copies files over ssh bidirectionally, will default to copy locally for composibility/compatibility and uses same args generally, which must be before the locations provided. typical use <code>scp user@host:/home/user/stuff stuff</code>. username is often needed. tab to complete works if you have passwordless ssh set up. USE IT PASSWORDLESS AND USE TAB. tab is slow though(it must open auth and close a ssh session in the background silently to achieve this). remember you can copy to /tmp always, too, if perms are giving you grief.</p>
</li>
<li>
<p><code>ssh -X &lt;remotehost&gt;</code> - this arg will forward x11, IE, let u run graphicalprograms over ssh(if u have x11 on both sides) <code>ssh -Y</code> is equivalent but was meant to be a more lightweight connection</p>
</li>
<li>
<p><code>ssh -A &lt;remotehost&gt;</code> - forward ssh agent to foreign server, allowing scure access to local keys on foreign server, including hardware tokens</p>
</li>
<li>
<p><code>ssh -D 8888 &lt;remotehost&gt;</code> - runs a socks5 proxy on prot 8888 that tunnels connections from localhsot through the remote host</p>
</li>
<li>
<p><code>ssh -L&lt;bindaddress&gt;:&lt;listen_port&gt;host:&lt;port&gt; user@remotehost</code> - tunnel localhost lport to remote host's view of host:port</p>
</li>
<li>
<p><code>ssh -R&lt;bindaddress&gt;:&lt;lport&gt;:host:&lt;port&gt; user@remotehost</code> - reverse tunnel, goes from remote host to  view of host:<port></p>
</li>
<li>
<p><code>sftp</code> - ftp style shell client for scp-like and other extended functionality</p>
</li>
<li>
<p><code>sshfs</code> - smount - use the above sftp facilities to emualted a mounted filesystem</p>
</li>
<li>
<p><code>ssh-copy-id, ssh-keyscan, ssh-agent</code> - other useful key management tools</p>
</li>
</ul>
<h1>operators in shell(bash)</h1>
<ul>
<li>
<p><code>|</code> pipe, puts stdout into stdin like <code>ps aux|grep &lt;word&gt;</code> looks for <code>&lt;word&gt;</code> in output of <code>ps aux</code> (list of running processes for all users)</p>
<ul>
<li><code>ls |tee bob</code> - example use of <code>tee</code>, this will write the directory contents to file <code>bob</code> while outputing them to stdout as well</li>
</ul>
</li>
<li>
<p><code>&amp;</code>  runs concurrently with following command.</p>
</li>
<li>
<p><code>&amp;&amp;</code>  run next program sequentially, if the first succeeds</p>
</li>
<li>
<p><code>||</code> run command after only  if the previous command fails</p>
</li>
<li>
<p><code>&gt;</code>  stdout into a file cat <code>bob &gt; file_name</code>. OVERWRITES THE FILE</p>
</li>
<li>
<p><code>&gt;&gt;</code>  APPENDS TO THE FILE like <code>ls &gt;&gt; listfile</code> will append contents of current directory to file listfile</p>
</li>
<li>
<p><code>2&gt;</code>  same as &gt; but does stderr, where <code>1&gt;</code> is just the default that <code>&gt;</code> alone reverts to</p>
</li>
<li>
<p><code>&amp;&gt;</code> - writes both stderr and stdout to filename after it</p>
</li>
<li>
<p><code>&lt;</code> file on right into stdin of command on left</p>
</li>
<li>
<p><code>&lt;&lt;&lt;</code>  string on the right into stdin on the left</p>
</li>
<li>
<p><code>ctrl-z</code>  pause - immediate effect always</p>
</li>
<li>
<p><code>ctrl-c</code> exit, doest leave shell(thats logout) clears the line though. sends a <code>kill -s 15</code> to the thread in foreground</p>
</li>
<li>
<p><code>ctrl-d</code> logout</p>
</li>
<li>
<p><code>[TAB]</code>  tab - hit this key a lot, it works to complete MANY things. used to just be files, now almsot anything. <code>git add [TAB] [TAB]</code> lists your changed files, for instance</p>
</li>
<li>
<p>back quotes - ``kill `pgrep firefox```  - inserts stdout from the command in backquotes into the shell as if you had typed it. pgrep outputs a list of pids that match the string you give it, here that is being picked up by kill so that it kills anything that matches firefox</p>
</li>
<li>
<p><code>*</code>  wildcard, <code>ls *.py</code> gives list of python scripts in current directory</p>
</li>
<li>
<p><code>!!</code>  the last command, <code>!n</code> nth command in history, <code>!-n</code> n commands back, IE <code>!-2</code> executes second last</p>
</li>
<li>
<p><code>!*</code> args from previous command</p>
</li>
<li>
<p><code>[0-9]</code>  matches digits in shell, <code>ls [0-9]*</code> list everything that starts with a digit. can use comma separated singletons, works with letters too [a-z]...</p>
</li>
</ul>
<h1>patrician word processing</h1>
<p>latex, reStructured text, markdown, are hypertext formats that compile into more visually aestetic document formats using various interpreters and compilers. This allows large documents to be written collaboratively under version control in git, and allows formatting to be decided after-the-fact, as well as other kinds of portability. Things like page size, fitment, numbering, reference style, file format, etc are determined by how they are compiled and options supplied at that time. docs for a project can be written in the same repo as the code and compiled into monographic pdfs, text formats, websites, books, powerpoint slides, etc. all from the same source, maintaining formatting and style automatically as determined by config files also kept in the repo. TeX is the most complex while markdown and rst are made to be easy on the eyes as sourcecode. all of them support the same format for math equations, which originally came from TeX and has been incorporated into wiki, notion, MS office, and basically every other document related software.</p>
<ul>
<li><code>latex</code> - compiles to dvi, pics gotta be eps(a vector format)</li>
<li><code>pdflatex</code>- compiles latex pics must be png and jpg i think. cant use vector format eps</li>
<li><code>htlatex</code>- good compiles latex to html with pics for equations and other floats</li>
<li><code>latex2html</code> - sucks. honorable mention thought</li>
<li><code>dvipdf</code> - turn dvi to pdf common for use of <code>latex</code></li>
<li><code>rst2html</code> - restructurted text to tml</li>
<li><code>rst2latex</code> - restructurted text to latex</li>
<li><code>rst2man</code> - restructurted text to man page</li>
<li><code>rst2odt</code> - restructurted text to odt</li>
<li><code>rst2pdf</code> - restructurted text to pdf</li>
<li><code>mistletoe</code> - markdown compiler python module with cli. compiles to html and latex and others</li>
<li><code>markdown</code> -  markdown, described as a "text-to-html filter"</li>
<li><code>convert</code> - very smartly interfaced command line front end for imagemagick. just <code>convert bob.&lt;ext&gt; bobout.jpg</code> etc to convert between any image format. this is helpful for latex etc.</li>
</ul>
<h1>root filesystem synopsis</h1>
<p>Int the past many of these were separate partitions, hence some of the seemingly redundant things. Now this is not as important with solid state drives and (i supposed) more modern file systems</p>
<ul>
<li><code>/tmp</code> - temp folder, anyone can write in it. it is there on every system and great place to copy things to if you are not sure where to do it</li>
<li><code>/etc</code> - pronounced et-SEE. all the configuration files and global settings are in here by default. in the past administration could be done exclusively by modificaion of files here, more or less. programs like passwd and usermod are tools to automatically edit files here. Disk usage is small as it is mostly text files and it is definitely something you want to back up, as it contains any system settings you took time configuring.</li>
<li><code>/var</code> - various data here, var/log is a default global spot for logs. often home to global data storage, such as the root of a  webserver with static content, or database disk footprint.</li>
<li><code>/usr</code> - user installed things generally.... comes with a lot in it these days. it is like an alternative root where u generally would modify things for system wide access. has the same directory structure as /</li>
<li><code>/proc</code> - process information emulated as block storage devices and stuff like this. can get info about some hardware from drivers, and access some other kernel level information pertaining to active system processes</li>
<li><code>/sys</code> - kernel emulated filesystem tree allowing information and interaction of various kernel level functionality and hardware devices. This includes the ability to read parameters from live kernel modules and set them by writing to said file as well, for example.</li>
<li><code>/run</code> - contains filesystem socket devices and other quasi-file dynamic objects written by userland software (as opposed to kernel level features in proc and sys)</li>
<li><code>/dev</code> - devices, access to raw hardware. it is a virtualized/emulated filesystem integrated representation of a group of non-file objects(very cool) like proc. these are not actual files, but dynamic emulated files that make access to devices like accessing a file. reading and writing to them is the same as a file. there are two styles of io, "block" and "character" devices. io is done by blocks(fixed size binary packets) or bytewise respectively</li>
<li><code>/opt</code> - not sure what it is supposed to be but it is often used to store globally accessed proprietary software that doesn't have facility to install in the typical global directory structure(where things are in /bin and /lib andprstuff</li>
<li><code>/bin</code> - binarys, these are where the commands are stored for the base system. most of the higher level stuff is in /usr/bin and /usr/local/bin</li>
<li><code>/home</code> - home directories for each user here. all user settings and information and data are in their home folder. copy it to an ew system an it will all be there</li>
<li><code>/root</code> - home directory for admin/root user</li>
<li><code>/boot</code> - contains the kernel and initial root disk, boot loader stuff IE GRUB. is more commonly a separate partition still</li>
<li><code>/cdrom</code> - vestigal artifact of a time when people used cdrom</li>
<li><code>/mnt</code> - this was originally where you would mount drives, IE, any drive that was not hosting system critical contents, like removable media, was mounted here. you added these to be automounted using /etc/fstab, and mounting had to be done by root</li>
<li><code>/media</code> - this is where thigns are mounted now, in a path like /media/<username>/<uuid serial thing>, this is now handled by some daemon that will do it for you as a setuid-to-root binary or something, to streamline the process of using removeable media since the proliferation of USB storage devices(previously portable storage media didnt carry its hardware interface with it, so the system wouldnt see new media as a new device entirely, but a change in state of a known device)</li>
</ul>
<h1>notable filesystem objects, global</h1>
<ul>
<li><code>/proc/cpuinfo</code> - cpu core info, pretty great</li>
<li><code>/dev/random</code> - random data from hardware. cat this and u get a dump of real physical entropy</li>
<li><code>/dev/urandom</code> - output of a psrng using above as seed. cat this and get infinite 'random' data generated from finite entropy harvested from ahrdware</li>
<li><code>/etc/passwd</code> - old school place where some user info is stored, originally included encrypted passwords. now it is where you go to look up info like groups and home directories and shells quickly. each line is a user and all of their <code>chsh</code> / <code>usermod</code> related properties</li>
<li><code>/etc/shadow</code> - where they moved the encrypted passwords and put them as only <code>r/w</code> by root and <code>r</code> group shadow  from passwd to hide them from users when ti as realzied they could be cracked</li>
<li><code>/etc/hosts</code> - lsit of hosts that are basically added to DNS, can put some of your servers here so u dont type ip</li>
<li><code>/etc/hostname</code> - yur hostname, for some reason i feel i usualy must edit this and use the hostname command at the same time/session</li>
<li><code>/etc/rc.local</code> - old school palce to put commands to have them run on boot, on many linux systems.</li>
<li><code>/etc/resolv.conf</code> - old way of keeping global nameservers. depends on the system now. In theory you can just add lines to add hosts but generally there is osme crackpot software stack hiding behind a local service that this file points to. way to make something overcomplicated.</li>
<li><code>/etc/motd</code> - text displayed at login. put stuff here if you have users, info about the system, advertisements, cuss them out, etc</li>
</ul>
<h1>notable filesystem objects, user</h1>
<ul>
<li><code>~</code> - alias to your homefolder <code>/home/&lt;username&gt;</code> also available as <code>$HOME</code></li>
<li><code>~/.ssh/authorized_keys</code> - put in a copy of someones id_rsa.pub file as a line, and it allows anyone with the corresponding private key to log into said account to whom <code>~</code> belongs.</li>
<li><code>~/.ssh/config</code> - lts u preconfig defults for various servers and things, pivotal wehn using scp and git reguarly. man ssh_config exists and shows syntax</li>
<li><code>~/.ssh/id_rsa.pub</code> - default place for public ssh key, without the <code>.ssh/id_rsa</code> is default for private, which, should be <code>chmod 600</code> for the perms</li>
<li><code>~/.bashrc</code> - if you use bash, this is a place you can add commands that run on login. such as adding things to your $PATH</li>
<li><code>~/.bash_history</code> - hitory of commands in bash, some cap length by default, grep this to find stuff you did and need th command for</li>
<li><code>~/.profile</code> - tis is like .bashrc but not specific to bash. on many systems, mac OSX and i believe other BSD. defintiely check if you are not using bash</li>
<li><code>~/.local/</code> - hs a root filesystem mirror structure that user installed things (like pip packages) can sit in. like a personal /usr/local. pip user installed stuff goes here, for example</li>
<li><code>~/.config/</code> - it is now considered best practice for packages to put their user config files in here rather than randomly as a hidden file or folder in ~</li>
</ul>
<h1>vim</h1>
<p>the interface style is called "a modal editor" this refers to the central characteristic of the user experience revolving around various "modes" that are specialized for different purposes. The main ones are <em>default</em>, <em>INSERT</em>, <em>VISUAL</em>. the first is the one you are in when you open it, and is good for moving around, viewing, etc. the second, <em>INSERT</em>, is the one you are using when you are editing, "like a normal editor", the third <em>VISUAL</em>, you enter by pressing v in default, and is good for selecting text characterwise and linewise to isolate operations to (delete blocks of text, copy paste, search replace on just selection).</p>
<ul>
<li><code>i</code> - enter insert mode</li>
<li><code>v</code> - enter visual mode</li>
<li><code>[esc]</code> - enter normal/default mode</li>
<li><code>:w &lt;file&gt;</code> - write, optionally to alternate file</li>
<li><code>:r &lt;file&gt;</code> - read file into buffer you are editing</li>
<li><code>:r! &lt;command&gt;</code> - spit output of command into buffer you are editing</li>
<li><code>:wq</code> - write and quit</li>
<li><code>:q!</code> - quit right now and dont ask about saving</li>
<li><code>d</code> - delete, <code>dd</code> deletes line, many other subcommands/variations <code>di(</code> deletes inside the parenthese you are in, works with every kind.</li>
<li><code>y</code> - "yank" copy to vim clipboard(not the system one) works the same as <code>d</code> which is not delete but more accurately a cut command</li>
<li><code>p</code> - paste things from the vim buffer(s) you filled with the above two commands</li>
<li><code>:help &lt;command&gt;</code> - get the help</li>
<li><code>=</code> - format, default code formatter, for C code i think</li>
</ul>
<h1>user ssh config</h1>
<p><code>~/.ssh/config</code> This is an import config file, sometimes it is absolutely necessarry if you are using scp and other ssh based utilities like git that sometimes do not have the ability to take the more advanced arguments you may need to give them, in the case of having multile users at the same host with multiple keys and things like this. see <code>man ssh_config</code></p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>Host bob
HostName bob.com
User userb
Port 222
IdentityFile ~/.ssh/id_rsa_bob</p>
</blockquote>
</blockquote>
<p>this enables you to simply <code>ssh bob</code>, and tab to complete works on this alias for te host. <code>HostName</code> is a misleading label, as it is the actual network address, dns or ip, and the aliasd you are giving it which will follow this setup every time is the first line in each entry <code>Host</code>. these aliases carry over to git commands and scp, etc</p>
<h1>host a git, barebones</h1>
<p>simple and dirty instructions
always use passwordless SSH for this
make git user on server. NO PASSWORD ON IT. no way to log in with password, furthermore, use git-shell
so that there is no way to go crazy on there running commands and tearing things up.</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>sudo useradd  -s <code>which git-shell</code> git
sudo su -s /bin/bash git
mkdir <package-name>
cd <package-name>
git init .
git config receive.denyCurrentBranch ignore #lets you push to bare repo</p>
</blockquote>
</blockquote>
<p>put public keys in <code>/home/git/.ssh/authorized_keys</code> as a line, on the host n</p>
<p>on cients:  <code>git clone ssh://git@server:/home/git/package</code></p>
<p>then make an initial commit to master to make sure it works</p>
<p>pull requests are a social media feature tied to the web interface and dont really exist in this setting. the command line utility will generate one, which is actually a diff format to sumarize changes between branches. opriginally meant to be emailed to the guy who controls the origin.</p>
<h1>git client side</h1>
<p>process of creating branch and merge:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>git checkout master
git pull  # make sure its up to date
git branch mybranchname # make a branch
git checkout mybranchname #- now you are on it, it is forekd off main
#do stuff, write code
git add stuff
git commit -m"new stuff"
git push #- upload it to the remote
#keep doing stuff, eventually ready to merge
git checkout master
git pull #-make sure its up to date
git merge mybranchname
#now if theres conflicts, you make sure it works, correct them.
#you can checkout a file from master by "git checkout <branch> <file>" to overwrite your ephemeral version(what you are editing in your environment) with one from a specific branch. add and commit as needed to resolve conflicts
git push
git branch -d mybranchname #delete the branch that you merged in, keep it from cluttering repo</p>
</blockquote>
</blockquote>
<p>git is very user friendly for a command line interface, gives useful messages and walks you through mnany processes
but remember to push after you merge, push and pull and clone are remote commands. commit, checkout, merge, etc, are local manipulation and interfacing with the underlying repo data structure that is entirely local, and entirely what git actually contributes as a software(version control). network communications with the remote are done with ssh or other protocols separate from git.  Git is useful without a remote, just to track progress and allow you to undo things if you mess up your code. noobs and people in the past that didnt have version control used to keep many copies of their code. This is inefficient and dangerous and sloppy. Cause of many tears, and something I am sure the suicide hotline operators are quite familiar with.</p>
<h1>docker</h1>
<p>docker is super helpful, especially if youre a noob. It allows you to do things as root but not destroy your baremetal system.</p>
<p>It was originally to make back end services scaleable, reproducible, and sandboxed while avoiding the use of a VM. apps in docker run on your kernel but network and disk is sandboxed and communicates through whatever avenues you specify(shared folders and port forwards). you can run things in docker seamlessly, including graphical interfaces. its a good way to silo sketchy ass commercial spyware-riddled-packages. good way to keep reproducible devleopment environments to remove variation between peoples systems on a dev team. it has a built in management system for images shared by project teams and the community.</p>
<p>if you dont use it youre basically failing at life. It is not something that requires a ton of knowledge or practice to benefit from. It is not only for enterprise sysadmin operations, either.</p>
<p>to get started you need to add user to docker group <code>usermod -aG docker &lt;user&gt;</code>, and then make a empty directory and put a file in it called Dockerfile, in which you list a series of commands building your custom system, generally starting with something from the docker repo. example including most of what you need:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>FROM ubuntu:latest #start with the baseline latest image
RUN apt-get update
RUN apt-get upgrade -y --force-yes
RUN apt-get install -y --no-install-recommends <packages> #only install the requirements and avoid any extra dependencies
RUN groupadd -g 1000 ubuntu
RUN useradd -d /home/ubuntu -s /bin/bash -m ubuntu -u 1000 -g 1000
USER ubuntu #rest of lines are as this user, as is runtime(default is root)
ENV HOME /home/ubuntu #set environment variable $HOME
RUN apt-get clean
#clean up, rm -rf basically anything you dont need to run the entrypoint
WORKDIR /workspace #in this file after this command and at runtime launch we are in /workspace
CMD <command> #whatever you put in for <command> will be the default entrypoint</p>
</blockquote>
</blockquote>
<p>then build with <code>docker build</code> and run with <code>docker run</code> with appropriate settings for network exposure and volume sharing etc.</p>
<ul>
<li><code>docker-compose</code> - utility for launching a few differentd ocker containers of different services, allowig you to easily config them to be interconnected in one file. simply put <code>docker-compose.yml</code> in an empty folder and edit/generate/write it to your specs. editing yaml can be kind of annoying due to autistic standards with whitespace and stuff. so work off of a copypaste</li>
<li><code>docker</code> - the normal interface to docker to run one container</li>
<li><code>docker stats</code> shows current running containers with resource use. important for noobs becuase people forget and leave them running</li>
<li><code>docker &lt;obj&gt; prune</code>- <code>&lt;obj&gt;</code> may be <code>container</code>, <code>image</code>, <code>volume</code>, <code>network</code> and maybe others i forget. this deletes the unused objects of said type, freeing up space.</li>
<li><code>docker run --rm -it --name box0 --device /dev/snd -v /etc/file:/etc/file:ro -v ~/stuff:/etc/stuff.d --net host  imagename:latest &lt;cmd&gt;</code> - reading this from left to right: run, remove when done, interactice session(dont run in background like nohup), name box0 on the running container, share host device /dev/snd, mount read only host /etc/file respectively in container, mount folder ~/stuff to /etc/stuff.d , share same network as host, run latest version of imagename, use <code>&lt;cmd&gt;</code> instead of default entrypoint</li>
</ul>
<h2>DONT</h2>
<ul>
<li><em>DONT</em> store data in a docker container. you store that in volumes or shared/mounted directories on host filesystem</li>
<li><em>DONT</em> try to keep persistent systems in docker, it is better to always <code>docker run --rm</code> to auto remove the container when you are done, and any changes that were needed should go to the Dockerfile. any config files and things should be in shared directories, safely stored on the host. containers should always be reproducible by automated build process defined in the Dockerfile</li>
<li><em>DONT</em> not run <code>apt-get clean</code> in Dockerfile. look for other things to delete too. ideally you make a second container from a lighter cleaner image and copy over the things you set up, leaving behind everything else</li>
<li><em>DONT</em> not use <code>apt-get --no-install-recomends</code></li>
<li><em>DONT</em> forget <code>DEBIAN_FRONTEND=noninteractive apt-get -y &lt;pkgs&gt;</code></li>
<li>to make small containers, you build your binaries and things in one container then copy to a smaller one without all the tools. There are specialized base containers for these two roles</li>
</ul>
